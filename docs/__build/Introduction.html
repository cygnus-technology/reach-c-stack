<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Cygnus Reach Programmers Introduction &#8212; Cygnus Reach Embedded Stack  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <!-----

You have some errors, warnings, or alerts. If you are using reckless mode, turn it off to see inline alerts.
* ERRORs: 0
* WARNINGs: 0
* ALERTS: 4

Conversion time: 4.359 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β35
* Tue Feb 13 2024 13:21:41 GMT-0800 (PST)
* Source doc: Cygnus Reach Programmers Intro
* Tables are currently converted to HTML tables.
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!

----->
<p><img alt="alt_text" src="C:%5CUsers%5Cchuck.peplinski%5Ccygnus%5Creacher-pb%5Creach-c-stack%5Cdocs%5Cimages%5CCygnusLogo_REACH-horiz-bg_light.png" /></p>
<section id="cygnus-reach-programmers-introduction">
<h1>Cygnus Reach Programmers Introduction<a class="headerlink" href="#cygnus-reach-programmers-introduction" title="Link to this heading">¶</a></h1>
<p>I3 Product Design</p>
<p>Version     2.0</p>
<p>Date        February 13, 2024</p>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
</section>
<section id="executive-summary">
<h1>Executive Summary<a class="headerlink" href="#executive-summary" title="Link to this heading">¶</a></h1>
<p>Cygnus Reach is a system to provide customer support to users of embedded IoT (Internet of Things) devices.  This support is also very useful to developers of such systems.</p>
<p>In case you aren’t familiar with Cygnus Reach, here are two links with some overview.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://cygnustechnology.com/">https://cygnustechnology.com/</a></p></li>
<li><p><a class="reference external" href="https://cygnustechnology.com/see-reach-in-action/">https://cygnustechnology.com/see-reach-in-action/</a></p></li>
</ul>
<p>This package demonstrates the code in the device.  It’s a small part of the Cygnus ecosystem.  This document describes the design of the Cygnus Reach IoT device platform as implemented on a common Silicon Labs SoC.  A companion “Getting Started” document provides more introduction.</p>
<p>The Cygnus Reach concept has some history at i3 where it has been deployed in a series of products.  This version is effectively a rewrite from the ground up.  It is designed to be deployed more widely with less customization required.</p>
<p>The SDK’s necessary to develop customized mobile app and web pages for Reach access are available through your Cygnus sales representative.</p>
<section id="audience">
<h2>Audience<a class="headerlink" href="#audience" title="Link to this heading">¶</a></h2>
<p>This document is addressed to the embedded developer who is considering using the Cygnus Reach system in a product.  The authors assume that the audience has some familiarity with the Cygnus Reach concept.  Cygnus Reach includes features such as video and screen sharing that are quite independent from the embedded device. This document is about the embedded device portion of the system.</p>
</section>
<section id="version-history">
<h2>Version History<a class="headerlink" href="#version-history" title="Link to this heading">¶</a></h2>
<p>1.1 : January 8, 2024, first public release.</p>
<p>2.0:  February 9, 2024.  Adds features such as parameter notifications.  Provided with a separate release note.</p>
</section>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading">¶</a></h1>
</section>
<section id="product-vision">
<h1>Product Vision<a class="headerlink" href="#product-vision" title="Link to this heading">¶</a></h1>
<p>The Reach stack enables the embedded system to be in contact with a mobile device over BLE for support and for development.</p>
<ul class="simple">
<li><p>Cygnus Reach is about supporting embedded devices.  The Cygnus Reach vision is to be a framework that is easily deployed into a range of products.  This requires several supporting components that are part of a larger ecosystem.</p></li>
<li><p>Customer support technicians are one user of Cygnus Reach.  But the product vision is for the Cygnus Reach device info interface to be of critical utility to the embedded developer.  Hence Cygnus Reach is not bolted on to an existing product but rather built in from the ground up.</p></li>
<li><p>The embedded developer must be able to expose the capabilities and debugging features of a device without creating a special web page.  The vision is to enable the embedded developer to construct the device info view without involving app or web developers.  This recommends a generic “display” client and an efficient data description mechanism.</p></li>
</ul>
</section>
<section id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h1>
<p>A typical Cygnus Reach system has at least two components:</p>
<ul class="simple">
<li><p>An embedded device acting as a “server” for its “device info” page.</p></li>
<li><p>A web page or an app with a rich user interface acting as a “client” to display the device info page.</p></li>
</ul>
<p>A mobile device may act as a “relay” to connect the embedded device to a web client.  The mobile device could also be the client on its own.</p>
<p>Bluetooth Low Energy (BLE) is most commonly used to communicate with the supported device, but other interfaces are possible if they are more appropriate.</p>
<p>The embedded server device and the display client must share a common language.  This is the Reach Protocol, described in a separate document. The interface is defined using “protobufs” to leverage the rich feature set supplied in multiple languages.</p>
<p>Reference implementations of embedded systems are available.  The Thunderboard demo runs on Silicon Labs very small BLE demo board.  The OpenPV reference version runs on an Enovation display.  Both talk to Android and iOS mobile devices.</p>
<p>The key features of the implementation include:</p>
<ul class="simple">
<li><p>Organization into pages that are convenient for users.</p></li>
<li><p>A standard way to identify the device and its firmware version(s).</p></li>
<li><p>A “parameter repository” to access control and status variables using a key-value pair model.</p></li>
<li><p>Access to a command line interface</p></li>
<li><p>A “file access” mechanism that supports high rate transfers of larger blocks of data.</p></li>
<li><p>A simple means to issue “commands” to the device.</p></li>
</ul>
<p>The two demo systems illustrate Reach on systems of different complexity.  The Linux based OpenPV displays from Enovation are an example of Reach in a sophisticated system.  The Thunderboard demo shows Reach with no OS as appropriate for tiny embedded systems.  Reach can certainly be deployed in everything in between, and there is ongoing development in other common systems.</p>
<p>The three system approach to support (device, phone, web page) is a key concept.  This acknowledges the three users in the system.  The product user has access to an embedded device as well as a mobile phone.  The support engineer uses a web browser so as to display data on a larger screen.  The embedded system designer is the third user, as the embedded system builder must include the support required.</p>
<p>A proper Cygnus Reach system design includes much input from customer support engineers.  The Cygnus Reach system exists to facilitate field support.  Hence the information presented to the support engineers must be what they need.  With new products the embedded system designer often has no customer support engineers available to provide design guidance.  Hence Cygnus Reach systems are often deployed in two phases.  The first phase exposes the things that the embedded system designer finds necessary.  The second phase tunes this to emphasize the things customer support needs to see first.</p>
<section id="id3">
<h2><a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
</section>
<section id="bluetooth-low-energy-ble">
<h2>Bluetooth Low Energy (BLE)<a class="headerlink" href="#bluetooth-low-energy-ble" title="Link to this heading">¶</a></h2>
<p>When presented on a BLE interface, the following interface must be implemented. This standard allows for immediate recognition by and compatibility with a Cygnus capable app.</p>
<p><strong>REACH BLE Service:</strong></p>
<p>UUID: edd59269-79b3-4ec2-a6a2-89bfb640f930</p>
<p><strong>Characteristics:</strong></p>
<p>The REACH API characteristic is all that is needed to enable access to the protocol. Client messages sent as individual characteristic writes and server responses are sent asynchronously as notifications.</p>
<table>
  <tr>
   <td><strong>Field</strong>
   </td>
   <td><strong>Description</strong>
   </td>
  </tr>
  <tr>
   <td>Name
   </td>
   <td>REACH API
   </td>
  </tr>
  <tr>
   <td>UUID
   </td>
   <td>d42d1039-1d11-4f10-bae6-5f3b44cf6439
   </td>
  </tr>
  <tr>
   <td>Type
   </td>
   <td>String
   </td>
  </tr>
  <tr>
   <td>Length
   </td>
   <td>Variable - up to max BLE APDU
   </td>
  </tr>
  <tr>
   <td>Properties
   </td>
   <td>Write, Read, Notify
   </td>
  </tr>
</table>
<p><strong>Advertisement:</strong></p>
<p>The BLE device must advertise this UUID so that mobile apps can identify it as a Cygnus device.  Note that the “Generic Access” service must also advertise to support long device names.</p>
<p><img alt="alt_text" src="C:%5CUsers%5Cchuck.peplinski%5Ccygnus%5Creacher-pb%5Creach-c-stack%5Cdocs%5Cimages%5CSiLabsBLE.png" /></p>
</section>
<section id="system-structure">
<h2>System Structure<a class="headerlink" href="#system-structure" title="Link to this heading">¶</a></h2>
<p>The Thunderboard demo has two parts, namely a “server” written in C and a “client” written in Kotlin or Swift or typescript.  The demo server runs on a Silicon Labs (SiLabs) Thunderboard.  It advertises itself as a Reach device on BLE.  Android and iOS mobile apps are available as the demo client.  These are available in the corresponding play/app store.  Cygnus also supports a web client.</p>
<p>The SiLabs demo is available on the Cygnus Technology github site (<a class="reference external" href="https://github.com/cygnus-technology">https://github.com/cygnus-technology</a>)</p>
<p>The code can be seen as three parts.  The “app” is specific to the product, which is the demonstration here.  A protobuf module defines the Reach protocolo and is shared with other systems.  The C language “Reach stack” (reach-c-stack) is reusable code that implements the Reach protocol with an appropriate interface to the app.  The entire set is built to port easily to other systems, whether in the SiLabs ecosystem or other BLE centric systems like those from Nordic.  The C-stack includes two files that target the SiLabs BLE interface.  These use a small and well defined interface to the rest of the stack.</p>
<p>How to build and run the demo is described elsewhere in the “Getting Started” document.</p>
</section>
<section id="porting-the-demo">
<h2>Porting the Demo<a class="headerlink" href="#porting-the-demo" title="Link to this heading">¶</a></h2>
<p>We encourage you to run the demo as is on the Thunderboard as it gives you a concrete reference.  This section outlines the process of porting the code to another system.  Here I assume it is a C project.</p>
<p>The demo uses no RTOS.  Everything goes through an event loop which is part of the SiLabs BLE architecture.  Reach could easily be broken off into a separate RTOS task, but this is not demonstrated.</p>
<p>The recommendation in general is to bring up your application so that it behaves just like the Reach demo, and then go on to customize it for your own usage.  The rest of this document attempts to give some background to better understand the application.</p>
<p>The demo application can be configured to print out the “wire” traffic in the form of the bytes sent over BLE.  This can be helpful when porting.</p>
<p>Begin by getting your BLE to work.  Get your system to advertise the Reach characteristic.</p>
<p>Next drop in the proto and c-stack parts of the project.  These should compile.</p>
<p>In the apps directory, the files that are prefixed with “reach” may need to be changed for your system.  The other files there can be thought of as a dummy database which you can use for testing.</p>
</section>
<section id="directory-structure">
<h2>Directory Structure<a class="headerlink" href="#directory-structure" title="Link to this heading">¶</a></h2>
<p>The “reach-tboard” project uses this top level directory structure.</p>
<section id="reach-c-stack">
<h3>Reach-c-stack<a class="headerlink" href="#reach-c-stack" title="Link to this heading">¶</a></h3>
<p>The directory “reach-c-stack” is also designed to be used unchanged.  The “silabs” directory in there supports working on Silicon Labs systems, but this is easily replaced if not appropriate.  The sources of all of this are provided.  Subject to all the usual caveats (don’t break things!) you can change these to debug and optimize.  It’s the protocol on the wire that must be matched.</p>
<ul class="simple">
<li><p>It provides the portable core of reach.  A user should not have to change this.  It could be provided as a library but we choose to provide it in source form.</p></li>
<li><p>Includes the “weak” functions that the app must implement.</p></li>
<li><p>Includes an IoT-Core directory with support functions for logging which rely on printf().</p></li>
<li><p>Includes a “lib” directory containing open source cJSON files.</p></li>
<li><p>Includes a “silabs” directory containing two files that target the stack at the SiLabs BLE interface.</p></li>
<li><p>Maintained as a git submodule to be reused by other projects.</p></li>
</ul>
</section>
<section id="reach-proto">
<h3>reach_proto<a class="headerlink" href="#reach-proto" title="Link to this heading">¶</a></h3>
<p>The directory “reach_proto” is the protobuf source.  Along with the .proto file there is a script that creates a .options file that matches the device code for BLE.  You can use the prebuilt C code for protobufs if you don’t want to bother with this script.  Nothing else in this directory should need to change.</p>
<ul class="simple">
<li><p>Includes a “proto” directory which includes the .proto source files.</p></li>
<li><p>Includes ansic/built directory with the generated .pb.c/.pb.h files.  These are provided so that users do not have to regenerate the files.  The procedure to regenerate the files is found in the readme.md file.</p></li>
<li><p>Maintained as a git submodule to be reused by other projects.</p></li>
</ul>
</section>
<section id="app">
<h3>App<a class="headerlink" href="#app" title="Link to this heading">¶</a></h3>
<p>The directory “app” defines the specific behavior of the demo.  It is structured to encourage your reuse.  There is a separate file for each “service”.  You can reuse most of this directly to get started.  A real project will likely change these files.  Functions that override the default “weak” crcb functions are defined in this directory.</p>
</section>
<section id="integrations">
<h3>Integrations<a class="headerlink" href="#integrations" title="Link to this heading">¶</a></h3>
<p>Code used to integrate Reach with a SiLabs system is stored here in a SiLabs directory.  Code for other integrations such as Nordic and Linux can also be placed here.  Each one implements the same set of callback functions.</p>
</section>
</section>
</section>
<section id="id4">
<h1><a class="headerlink" href="#id4" title="Link to this heading">¶</a></h1>
</section>
<section id="application-structure">
<h1>Application Structure<a class="headerlink" href="#application-structure" title="Link to this heading">¶</a></h1>
<p>The Reach embedded system is written in C specifically to remain attractive to very small and simple embedded systems.  A number of design decisions follow from this.</p>
<ol class="arabic simple">
<li><p>The core Reach stack, which is provided by i3, should be reusable without changes on multiple platforms.</p></li>
<li><p>The core Reach stack relies on a set of callback functions that must be implemented by the target application.  We refer to these as “the weak functions” because they are implemented using the gcc “weak” feature.  This allows us to avoid the function pointers which add complexity to debugging.  These functions are prefixed with “crcb_”</p></li>
<li><p>Since C has no formal namespace support the reach stack uses prefixes when variables must be shared between files.  When possible variables are kept static, but the naming convention allows for functions to be isolated in files of reasonable sizes.</p></li>
<li><p>Malloc is not used.  Large data structures are not instantiated on the stack.  The buffers that are used to code and move data are statically allocated.</p></li>
<li><p>The .options features of nanopb are used to statically define the memory used for protobuf handling.</p></li>
<li><p>The .options file is generated using an H file.  This allows an application to change the buffer sizes.  The sizes are tuned for BLE.</p></li>
<li><p>A top level H file, “reach-server.h” defines many characteristics of the system that can be altered at build time.</p></li>
</ol>
<section id="event-loop-structure">
<h2>Event Loop Structure<a class="headerlink" href="#event-loop-structure" title="Link to this heading">¶</a></h2>
<p>From the point of view of an application designer, the reach code is all executed in a single “cr_process()” function which must be called with some regularity.  The process function will typically exchange one message with the client over BLE.  The process function is called with a tick count, which would typically be milliseconds since system start so that the reach stack can include support for timed notifications.  But the details of how this is implemented in the customers system are very flexible.  A system with an RTOS might run Reach in a task.  A system without an RTOS might call the process function in its loop.  The reach stack calls back into the application using the “weak” functions.  The embedded system must override these weak callback functions to provide the reach stack with what it needs.</p>
<p>The cr_process() function has nothing to do when the (BLE) communication link is not connecting the device and the client, so cr_process() returns and does nothing in this case.</p>
<section id="threading-concerns">
<h3>Threading concerns<a class="headerlink" href="#threading-concerns" title="Link to this heading">¶</a></h3>
<p>All traffic flows through the cr_process() function.  It is called from one thread.  Hence the Reach system is built to be single threaded and no mutex protection is necessary.  The remote CLI support adds some complexity in that it can produce data at any time.  This is why it uses separate communication buffers.</p>
</section>
<section id="feeding-data">
<h3>Feeding Data<a class="headerlink" href="#feeding-data" title="Link to this heading">¶</a></h3>
<p>Data can be pushed into the stack or pulled from the surrounding application.  The BLE code pushed coded data into the stack by calling cr_store_coded_prompt().  The socket based test harness overrides the implementation of crcb_get_coded_prompt() to accept data from a socket.  The weak default implementation of crcb_get_coded_prompt() assumes that cr_store_coded_prompt() has been called.</p>
<p>A similar dichotomy exists with the coded reply.  The socket based test app calls crcb_send_coded_response() which is overridden to send to a socket.</p>
</section>
</section>
<section id="client-server-architecture">
<h2>Client - Server Architecture<a class="headerlink" href="#client-server-architecture" title="Link to this heading">¶</a></h2>
<p>Reach generally states that the embedded device is a server and the phone is a client.  This implies that the server only responds to requests from the client.  The sort of asynchronous notifications required to support a remote command line go against this flow.  This has not been a problem in BLE systems, but when we test using a socket link we find that we must create a second socket pair oriented in the opposite direction.</p>
<p>An easy way to think about this is to consider the device as a server for most of the Reach protocol.  Notifications are an exception because there the device acts more like a client.  While the bulk of the Reach protocol is initiated by the mobile device as a client, notifications are initiated by the embedded device.  An easy way to handle this is to create an independent communication path for the notifications generated by the device.</p>
<p>Examples of “notifications” that come to the mobile device without prompt are:</p>
<ul class="simple">
<li><p>Error reports</p></li>
<li><p>Remote command line</p></li>
<li><p>Parameter notifications</p></li>
</ul>
</section>
</section>
<section id="on-logging">
<h1>On Logging<a class="headerlink" href="#on-logging" title="Link to this heading">¶</a></h1>
<p>Printf style logging and a command line interface are fundamental to embedded development.  The reach system relies on the logging support features that are documented here. The reach system provides a rich set of support for these features.  In addition to the serial port traditionally used, reach  supports a command line interface over the BLE connection.  Other solutions could be substituted if appropriate.</p>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h2>
<p>The authors worked off of this set of requirements for logging:</p>
<ol class="arabic simple">
<li><p>Users must be able to enable and disable logging on a per-function basis.  This must be configurable via the command line at run time.  Log calls are provided with a “mask” to serve this purpose.</p></li>
<li><p>“Levels” separate from masks are unnecessary.  The typical hierarchy of error, warn, debug, info, etc. is too limiting.  Masks take this place and masks must be per function.</p></li>
<li><p>A “\n” line ending is provided by default, but it must be possible to print into the buffer “bare” without this termination.  LOG_MASK_BARE allows for this.</p></li>
<li><p>Log entries classed as “error”, “warning” and “always” cannot be disabled by the mask.  Errors are printed red.  Warings are yellow.  Always is white.</p></li>
<li><p>Function and line are not included by default.  Users add them where appropriate.</p></li>
<li><p>Reach defines a set of masks that can be used to debug its internal functions.  Other mask bits are reserved to user applications.</p></li>
<li><p>It must be possible to turn off all logging at build time to minimize size.</p></li>
<li><p>It must be possible to access the CLI remotely.</p></li>
</ol>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h2>
<p>All of this is supplied by i3_log.h/.c.  As provided, iI3_log.relies on printf.  This can be ported as necessary.  More information on the remote CLI is provided in a subsequent section.</p>
<p>The “lm” command (for log mask) enables the user to see more or less logging.  Commanding “lm” alone shows the settings.  The log masks are defined in i3_log.h:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span>  <span class="n">The</span> <span class="n">lowest</span> <span class="n">nibble</span> <span class="ow">is</span> <span class="n">reserved</span> <span class="n">to</span> <span class="n">system</span> <span class="n">things</span><span class="o">.</span>
<span class="c1">#define LOG_MASK_ALWAYS     0x01    // Cannot be suppressed</span>
<span class="c1">#define LOG_MASK_ERROR      0x02    // Prints red, cannot be suppressed</span>
<span class="c1">#define LOG_MASK_WARN       0x04    // Prints yellow, cannot be suppressed</span>
<span class="c1">#define LOG_MASK_BARE       0x08    // trailing \n is omitted</span>
<span class="c1">#define LOG_MASK_REMOTE     0x10    // Set this to indicate that a message should be shared remotely.</span>

<span class="o">//</span> <span class="n">These</span> <span class="n">used</span> <span class="n">by</span> <span class="n">Reach</span> <span class="n">features</span><span class="o">.</span>  <span class="n">Enable</span> <span class="n">them</span> <span class="n">to</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">understand</span><span class="o">.</span>
<span class="c1">#define LOG_MASK_WEAK       0x20    // print in weak functions</span>
<span class="c1">#define LOG_MASK_WIRE       0x40    // show what is on the wire</span>
<span class="c1">#define LOG_MASK_REACH      0x80    // show reach protocol exchanges</span>
<span class="c1">#define LOG_MASK_PARAMS     0x100</span>
<span class="c1">#define LOG_MASK_FILES      0x200</span>
</pre></div>
</div>
</section>
</section>
<section id="id5">
<h1><a class="headerlink" href="#id5" title="Link to this heading">¶</a></h1>
</section>
<section id="using-protobufs">
<h1>Using Protobufs<a class="headerlink" href="#using-protobufs" title="Link to this heading">¶</a></h1>
<p>We use nanopb to convert the .proto file into C structures.  Following nanopb guidelines, we use a .options file to avoid the use of malloc().  All arrays are converted to fixed sizes which are set in the .options file.  The .options file is generated using a python script, reach_proto\proto\preprocess_options.py.  This reads in reach-c-stack/reach_ble_proto_sizes.h and a prototype of the options file and outputs an options file that reflects the sizes set by the device.  The sizes here are optimized for efficient BLE transfer.  A system that does not use BLE could adjust these sizes.  The UI applications are designed to respect these size constraints that are advertised in the device info structure.</p>
<section id="protobuf-version-handling">
<h2>Protobuf Version Handling<a class="headerlink" href="#protobuf-version-handling" title="Link to this heading">¶</a></h2>
<p>The device information structure includes a protocol_version member.  The device populates this with cr_ReachProtoVersion_CURRENT_VERSION which comes from the proto file.  The mobile or web app functioning as the reach client compares this value to the value that it found in the .proto file.  They should be the same.  The protobuf concept allows quite a bit of flexibility in the way of adding things to the interface.  Consider two use cases:</p>
<ol class="arabic simple">
<li><p>A product in the field might implement new features in a firmware update.  The system should be aware of this from the firmware version in the device info structure.  But a system designer might decide to change something significant in the protobuf file.  This version can be used to choose two code branches to support the two versions.</p></li>
<li><p>While this version should not change in release, an application in development might see different versions of the proto file.  It is expected behavior that the client will compare the protocol version it reads from its local .proto file with the protocol version received from the server.  Warn the user if these two do not match!</p></li>
</ol>
<p>The protobuf version is available as an enum in the device C code.  The example application currently exposes it to the client using parameter ID 25.</p>
</section>
</section>
<section id="id6">
<h1><a class="headerlink" href="#id6" title="Link to this heading">¶</a></h1>
</section>
<section id="on-memory-allocation">
<h1>On Memory Allocation<a class="headerlink" href="#on-memory-allocation" title="Link to this heading">¶</a></h1>
<p>The thunderboard reach system does not rely on malloc.  All memory allocation is static.  The protobuf system uses dynamic memory allocation in languages like Java that have garbage collection.  Using dynamic allocation in C puts the responsibility on the caller to free the memory and the authors wish to avoid this.</p>
<section id="memory-usage">
<h2>Memory Usage<a class="headerlink" href="#memory-usage" title="Link to this heading">¶</a></h2>
<p>The Reach thunderboard application version 3.1.9 was analyzed for memory usage by sorting the output of the “nm” tool.  These numbers are approximate.  The code was compiled with -Os for size.  These values are intended to give an order of magnitude overview of memory usage.  Consider in particular the memory requirements that scale with the number of parameters.</p>
<ul class="simple">
<li><p>The reach demo application takes up about 245k of flash memory with logging enabled.</p>
<ul>
<li><p>The “NO_LOGGING” macro reduces this by about 14k.</p></li>
</ul>
</li>
<li><p>The Reach demo code with protobufs occupies about 17k bytes in flash</p>
<ul>
<li><p>4500 bytes for the primary Reach library</p></li>
<li><p>2330 bytes for the callbacks.</p></li>
<li><p>5190 bytes for the protobuf library code</p></li>
<li><p>1988 bytes for the protobuf initialization data</p></li>
<li><p>1364 bytes for the Reach interface to the SiLabs BLE stack.</p></li>
<li><p>348 bytes for the i3 log functions</p></li>
<li><p>1920 bytes for the CLI functions</p></li>
</ul>
</li>
<li><p>Further flash describes parameters, commands and files:</p>
<ul>
<li><p>180 bytes per parameter</p></li>
<li><p>28 bytes per command</p></li>
<li><p>40 bytes per file</p></li>
</ul>
</li>
<li><p>Reach data requires about 2k in RAM, mainly for communication buffers.</p></li>
<li><p>Parameter values occupy 56 bytes of RAM each.</p></li>
</ul>
<p>Reach 3.3.0 consistently deployed #defines such as “INCLUDE_PARAMETER_SERVICE” for each optional service.  The difference in code size between all optional services included and all optional services excluded was about 22k (250k - 228k).</p>
</section>
<section id="communication-buffer-structure">
<h2>Communication Buffer Structure<a class="headerlink" href="#communication-buffer-structure" title="Link to this heading">¶</a></h2>
<p>Reach conceptually uses six buffers to exchange prompts and replies.  Each buffer is nominally 244 bytes, matching the BLE buffer size.  The third buffer points to the first buffer as it can easily be reused.  A further reduction of one buffer could be accomplished by encoding the payload directly into the outer message structure, but this makes the code rather confusing so this optimization is not shared.</p>
<ol class="arabic">
<li><p><strong>sCr_encoded_message_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Received encoded prompt message to be decoded.
</pre></div>
</div>
</li>
<li><p><strong>cr_ReachMessage sCr_uncoded_message_structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Contains the encoded prompt separated from the header.

 Also used for enccoding.
</pre></div>
</div>
</li>
<li><p><strong>sCr_decoded_prompt_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Decoded prompt to be processed.

 Reuses the sCr_encoded_message_buffer.
</pre></div>
</div>
</li>
<li><p><strong>sCr_uncoded_response_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Raw payload data to be encoded
</pre></div>
</div>
</li>
<li><p><strong>sCr_encoded_payload_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Payload encoded.

 The payload could be encoded directly into sCr_uncoded_message_structure saving a buffer at the cost of added complexity.  The encoded payload is currently copied into the **sCr_uncoded_message_structure**
</pre></div>
</div>
</li>
<li><p><strong>sCr_encoded_response_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Encoded message ready to be transmitted
</pre></div>
</div>
</li>
</ol>
<p>A separate pair of “ping pong” buffers are used to encode notifications.</p>
</section>
</section>
<section id="services">
<h1>Services<a class="headerlink" href="#services" title="Link to this heading">¶</a></h1>
<p>Reach devices advertise that they support a set of “services” such as “parameters”, “files” and “commands”.  Reach devices can implement as many or as few services as are appropriate.  Support for each service is segregated into separate files in the apps directory.</p>
<section id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Link to this heading">¶</a></h2>
<p>The file App/reach-server.h is designed to be used to configure your use of Reach.  Use #defines to include or exclude services.</p>
</section>
<section id="device-information-service">
<h2>Device Information Service<a class="headerlink" href="#device-information-service" title="Link to this heading">¶</a></h2>
<p>Device.c implements the crcb_device_get_info() callback function, overriding its weak prototype.  The device info service is required so this function is required.  The basic description of the product can be constant in flash but a copy is made so that parts can be overridden.</p>
</section>
<section id="parameter-service">
<h2>Parameter Service<a class="headerlink" href="#parameter-service" title="Link to this heading">¶</a></h2>
<p>Params.c implements the necessary support for a simple parameter database.  Descriptions of parameters can be stored in flash with the variable data stored in RAM.  The demonstration code includes the storage of parameters in non-volatile memory (NVM).  The various callback functions used are all implemented here.  The interface is designed to support product specific implementations of the parameter database.  The provided parameter repository is quite simple, but it may be sufficient for many applications.</p>
<p>The parameter interface is designed to support small variables.  Byte arrays up to 32 bytes are supported.  Larger data blocks can be handled using the file service.</p>
<section id="parameter-notifications">
<h3>Parameter Notifications<a class="headerlink" href="#parameter-notifications" title="Link to this heading">¶</a></h3>
<p>Parameters can be configured to notify the client on change.  The configuration of notifications must be commanded each time a client connects to a device/server.  A notification is specified using three variables:</p>
<ul class="simple">
<li><p>Delta</p>
<ul>
<li><p>Delta specifies that the server will notify the client if the value changes by this much since the last reported change.</p></li>
</ul>
</li>
<li><p>Max period</p>
<ul>
<li><p>When the max period is set the server will generate a notification at this time even if no other change has happened.</p></li>
</ul>
</li>
<li><p>Min period</p>
<ul>
<li><p>The min period limits the frequency of rapidly changing things.  If you set the min period to 10 seconds and your parameter is crossing its delta hundreds of times per second you will only get a notification every 10 seconds.</p></li>
</ul>
</li>
</ul>
<p>These can be used together.</p>
<p>When the BLE connection is made and the reach stack is active the parameters that are configured for notification are read using the crcb_parameter_read() callback function in the main process loop (cr_process()).</p>
<p>Some items to keep in mind are:</p>
<ul class="simple">
<li><p>The number of parameters that can generate notifications is set by NUM_SUPPORTED_PARAM_NOTIFY in reach-server.h.  Each notification requires another 56+20 bytes.</p></li>
<li><p>Parameters are only monitored when the BLE client is connected.</p></li>
<li><p>All parameter notifications are canceled when the client connects to the device.  The client must enable all desired notifications when it connects.</p></li>
<li><p>Setting any of the notification parameters to zero means they will be ignored.  Setting all of them to zero (delta, min, max) is the same as disabling that notification.</p></li>
<li><p>No delta applies for strings and byte arrays.  They are checked for any change by strcmp() and memcmp() respectively.</p></li>
</ul>
</section>
</section>
<section id="command-service">
<h2>Command Service<a class="headerlink" href="#command-service" title="Link to this heading">¶</a></h2>
<p>The command service provides an easy way to execute simple functions not requiring parameters.</p>
</section>
<section id="file-service">
<h2>File Service<a class="headerlink" href="#file-service" title="Link to this heading">¶</a></h2>
<p>The file service provides for the efficient transfer of larger blocks of data.  The file service only describes the transfer of data.  Callback functions must retrieve or store the data.  The example provides synthetic data.  The data associated with a file may or may not be stored in any formal file system.  This is entirely up to the device designer.</p>
</section>
<section id="cli-command-line-interface">
<h2>CLI (Command Line Interface)<a class="headerlink" href="#cli-command-line-interface" title="Link to this heading">¶</a></h2>
<p>The CLI service allows for debug access to aspects of the system that might not be deemed important enough for official support.  As embedded developers typically use the CLI, the authors have found that making this command line interface available to the support team often provides a necessary back to to solve real problems.  The CLI interface is made optional here via a define in reach_server.h.  The remote CLI echo is also disabled by default as it causes a lot of BLE traffic which can be confusing.</p>
</section>
<section id="time-service">
<h2>Time Service<a class="headerlink" href="#time-service" title="Link to this heading">¶</a></h2>
<p>The time service is designed to support setting and checking the time on devices that use a real time clock (RTC).  The time is represented by a 64 bit seconds field which should contain the UTC time in the Linux Epoch (since 1970).  The time also includes a “timezone” field which is a correction to the UTC time, also given in seconds.  The timezone field is optional, and so in theory timezones could be ignored, but we don’t recommend this for a collection or reasons that come up in development.</p>
</section>
<section id="files-parameters-and-commands">
<h2>Files, Parameters, and Commands<a class="headerlink" href="#files-parameters-and-commands" title="Link to this heading">¶</a></h2>
<p>Parameters are supported using a simple key-value pair structure.  The decision to avoid dynamic memory allocation causes the parameter storage structure to have a fixed and limited size.  The limit is set to 32 bytes for a string.  Data that is too large for this is easily handled using the “file” construct.  Reach provides no formal file system.  Files can instead be thought of as a key-value pair in which the value size is not limited.  While the parameter structure is optimized to fetch several parameters together, the file structure is optimized to transfer a larger block of data as quickly as possible.  “Files” can be mapped to a file system if that is appropriate for the application.  They can also simply be larger blocks of data maintained by the app.</p>
<p>Commands provide a simple means to remotely trigger a function with fixed parameters.  Commands could always be implemented in other ways.  An example is the command to enable the remote CLI.  This can also be engaged using the command line, but providing a command makes it easier to get started with these features.</p>
</section>
</section>
<section id="id7">
<h1><a class="headerlink" href="#id7" title="Link to this heading">¶</a></h1>
</section>
<section id="multi-message-continuing-transactions">
<h1>Multi-Message (Continuing) Transactions<a class="headerlink" href="#multi-message-continuing-transactions" title="Link to this heading">¶</a></h1>
<p>The response to DISCOVER_PARAMETERS, and in fact to any “discover” command could extend over multiple “messages”.  To define terms:</p>
<ul class="simple">
<li><p>A _transaction _is a series of messages.</p></li>
<li><p>A _message _has a _header _and a <em>payload</em>.</p></li>
<li><p>The _prompt _is a received payload.</p></li>
<li><p>The _response _is a generated payload.</p></li>
<li><p>When transferring a file there is a further entity known as the “<em>transfer</em>”.  The file (read) is a <em>transaction</em>.  It can be made up of a series of <em>transfers</em>, each terminated by an acknowledgement.</p></li>
</ul>
<p>The response to any “discover” message may require several messages to complete the transaction.  For this purpose the cr_process() function must call a handle_continued_transactions() function before looking for a new prompt.  The reach system must keep track of any continuing transactions.</p>
<p>Each discover handler first checks whether the request is null.  The request will be valid if this is a new request and it will be null if called for a repeating request.</p>
<p>The system stores a “continued_message_type” as well as at “num_remaining_objects”.  The handle_continued_transactions() function first looks at the continued_message_type.  It will be invalid when there is no continuing transaction.  If there is such a transaction pending the continued_message_type tells us what it is.  The appropriate handler function produces a payload which is encoded and we exit the cr_process() function with the encoded message.</p>
<p>The various messages in a multi-message transaction are tagged with the same transaction_id in their header.  This is helpful when checking for timeouts in the communication.  Each transaction has a defined timeout and its completion is easily determined.</p>
<p>File transfers are made in a series of transactions.  A transfer_id is included in the payload to tie this series of transactions together.</p>
</section>
<section id="id8">
<h1><a class="headerlink" href="#id8" title="Link to this heading">¶</a></h1>
<section id="read-file-sequence">
<h2>Read File Sequence<a class="headerlink" href="#read-file-sequence" title="Link to this heading">¶</a></h2>
<p>Reading a file exercises a sequence of transactions.  The sequence is tracked by a state structure in the stack.  The application must simply provide a function to read the data.</p>
<p>(Phone sends)     Transfer Init</p>
<ul class="simple">
<li><p>File ID, read/write, size, offset,</p></li>
<li><p>Messages per ACK, Transfer_id</p></li>
</ul>
<p>(device responds)         Transfer Init Reply  (error if not allowed)</p>
<p>Repeat:</p>
<p>(Phone sends)     Transfer Data Notification (SW CTS):</p>
<ul>
<li><p>Phone should be able to timeout.</p>
<p>(Device Responds)    (multiple) Transfer Data messages.</p>
</li>
<li><p>device sends N messages before waiting for an ACK.</p></li>
<li><p>Phone should be able to timeout.</p></li>
</ul>
<p>(phone sends)        Final Transfer Data Notification, with “is_complete” : true</p>
<p><img alt="alt_text" src="C:%5CUsers%5Cchuck.peplinski%5Ccygnus%5Creacher-pb%5Creach-c-stack%5Cdocs%5Cimages%5Cfile_read_sequence.png" /></p>
</section>
<section id="write-file-sequence">
<h2>Write File Sequence<a class="headerlink" href="#write-file-sequence" title="Link to this heading">¶</a></h2>
<p>After the discover sequence, a file is written using a sequence of transactions.  All files are binary data.</p>
<p>(Phone sends)     Transfer Init</p>
<ul class="simple">
<li><p>File ID, read/write, size, offset,</p></li>
<li><p>Messages per ACK</p></li>
<li><p>Transfer_id</p></li>
</ul>
<p>(device responds)     Transfer Init Reply  (error if not allowed)</p>
<p>Repeat:</p>
<p>(Phone sends)     (multiple) Transfer Data messages.</p>
<ul>
<li><p>phone waits for an ACK after N messages.</p></li>
<li><p>Phone must be able to timeout if ACK is not received.</p>
<p>(device sends)     Transfer Data Notification (SW CTS):</p>
</li>
<li><p>OK, is_complete</p></li>
</ul>
</section>
</section>
<section id="id9">
<h1><a class="headerlink" href="#id9" title="Link to this heading">¶</a></h1>
<p><img alt="alt_text" src="C:%5CUsers%5Cchuck.peplinski%5Ccygnus%5Creacher-pb%5Creach-c-stack%5Cdocs%5Cimages%5Cfile_write_sequence.png" /></p>
</section>
<section id="error-handling">
<h1>Error Handling<a class="headerlink" href="#error-handling" title="Link to this heading">¶</a></h1>
<p>Error reporting is considered important and hence Reach provides a method by which a textual error message can be delivered to the remote client.  This is demonstrated in a number of ways, including under the “TEST_ERROR_REPORT” define in cr_stack.c.</p>
</section>
<section id="endpoints">
<h1>Endpoints<a class="headerlink" href="#endpoints" title="Link to this heading">¶</a></h1>
<p>The top level Reach message structure includes an endpoint entry.  As this top level structure is for routing, we should use this to route messages to an endpoint.  The device info structure is intended to include a map listing the endpoints that are available here.  Endpoint zero contains this map.  The thunderboard system has only one endpoint.</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Cygnus Reach Embedded Stack</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/index.html">Tutorials <code class="docutils literal notranslate"><span class="pre">tutorials/index.md</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="programmers_guide/index.html">Programmers Guide <code class="docutils literal notranslate"><span class="pre">programmers_guide/index.md</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="api_reference/index.html">API Reference <code class="docutils literal notranslate"><span class="pre">api_reference/index.md</span></code></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Chuck Peplinski, Peter S. Jamrozinski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/Introduction.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>