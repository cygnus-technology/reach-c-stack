/********************************************************************************************
 *    _ ____  ___             _         _     ___              _                        _
 *   (_)__ / | _ \_ _ ___  __| |_  _ __| |_  |   \ _____ _____| |___ _ __ _ __  ___ _ _| |_
 *   | ||_ \ |  _/ '_/ _ \/ _` | || / _|  _| | |) / -_) V / -_) / _ \ '_ \ '  \/ -_) ' \  _|
 *   |_|___/ |_| |_| \___/\__,_|\_,_\__|\__| |___/\___|\_/\___|_\___/ .__/_|_|_\___|_||_\__|
 *                                                                  |_|
 *                           -----------------------------------
 *                          Copyright i3 Product Development 2024
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @file      definitions.c
 * @brief     A minimal implementation of Reach data access.  Auto-generated by a Python script.
 * @copyright 2023-2024 i3 Product Development. All Rights Reserved.
 *
 * Original Author: Chuck Peplinski
 * Script Author: Joseph Peplinski
 *
 *
 ********************************************************************************************/

#include "definitions.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "i3_log.h"
#include "app_version.h"
#include "cr_stack.h"

// Extra includes and forward declarations here.
// User code start [P1]
// User code end [P1]



void init_param_repo()
{
    int rval = 0;
    // rval = app_handle_param_repo_pre_init();
    // User code start [P2]
    // User code end [P2]
    if (rval)
    {
        I3_LOG(LOG_MASK_ERROR, "App-specific param repo pre-init failed (error %d), continuing with init", rval);
    }
    memset(sCr_param_val, 0, sizeof(sCr_param_val));
    for (int i=0; i<NUM_PARAMS; i++)
    {
        sCr_param_val[i].parameter_id = param_desc[i].id;

        // the PID directly maps to the parameter type, just to make it easy.
        switch ((param_desc[i].which_desc - cr_ParameterInfo_uint32_desc_tag))
        {
        case cr_ParameterDataType_UINT32:
            if (param_desc[i].desc.uint32_desc.has_default_value)
                sCr_param_val[i].value.uint32_value = param_desc[i].desc.uint32_desc.default_value;
            break;
        case cr_ParameterDataType_INT32:
            if (param_desc[i].desc.int32_desc.has_default_value)
                sCr_param_val[i].value.int32_value = param_desc[i].desc.int32_desc.default_value;
            break;
        case cr_ParameterDataType_FLOAT32:
            if (param_desc[i].desc.float32_desc.has_default_value)
                sCr_param_val[i].value.float32_value = param_desc[i].desc.float32_desc.default_value;
            break;
        case cr_ParameterDataType_UINT64:
            if (param_desc[i].desc.uint64_desc.has_default_value)
                sCr_param_val[i].value.uint64_value = param_desc[i].desc.uint64_desc.default_value;
            break;
        case cr_ParameterDataType_INT64:
            if (param_desc[i].desc.int64_desc.has_default_value)
                sCr_param_val[i].value.int64_value = param_desc[i].desc.int64_desc.default_value;
            break;
        case cr_ParameterDataType_FLOAT64:
            if (param_desc[i].desc.float64_desc.has_default_value)
                sCr_param_val[i].value.float64_value = param_desc[i].desc.float64_desc.default_value;
            break;
        case cr_ParameterDataType_BOOL:
            if (param_desc[i].desc.bool_desc.has_default_value)
                sCr_param_val[i].value.bool_value = param_desc[i].desc.bool_desc.default_value;
            break;
        case cr_ParameterDataType_STRING:
            if (param_desc[i].desc.string_desc.has_default_value)
            {
                memset(sCr_param_val[i].value.string_value, 0, sizeof(sCr_param_val[i].value.string_value));
                memcpy(sCr_param_val[i].value.string_value, param_desc[i].desc.string_desc.default_value, sizeof(param_desc[i].desc.string_desc.default_value));
            }
            break;
        case cr_ParameterDataType_ENUMERATION:
            if (param_desc[i].desc.enum_desc.has_default_value)
                sCr_param_val[i].value.enum_value = param_desc[i].desc.enum_desc.default_value;
            break;
        case cr_ParameterDataType_BIT_FIELD:
            if (param_desc[i].desc.bitfield_desc.has_default_value)
                sCr_param_val[i].value.bitfield_value = param_desc[i].desc.bitfield_desc.default_value;
            break;
        case cr_ParameterDataType_BYTE_ARRAY:
            if (param_desc[i].desc.bytearray_desc.has_default_value)
            {
                sCr_param_val[i].value.bytes_value.size = param_desc[i].desc.bytearray_desc.default_value.size;
                memcpy(sCr_param_val[i].value.bytes_value.bytes, param_desc[i].desc.bytearray_desc.default_value.bytes, sizeof(param_desc[i].desc.bytearray_desc.default_value.bytes));
            }
            else
            {
                sCr_param_val[i].value.bytes_value.size = param_desc[i].desc.bytearray_desc.max_size;
                memset(sCr_param_val[i].value.bytes_value.bytes, 0, sCr_param_val[i].value.bytes_value.size);
            }
            break;
        default:
            affirm(0);  // should not happen.
            break;
        }  // end switch

        // Convert from description type identifier to value type identifier
        sCr_param_val[i].which_value = (param_desc[i].which_desc - cr_ParameterInfo_uint32_desc_tag) + cr_ParameterValue_uint32_value_tag;

        if (param_desc[i].storage_location == cr_StorageLocation_STORAGE_LOCATION_INVALID || param_desc[i].storage_location > cr_StorageLocation_NONVOLATILE_EXTENDED)
        {
          I3_LOG(LOG_MASK_ERROR, "At param index %d, invalid storage location %d.",
                 i, param_desc[i].storage_location);
        }

        // rval = app_handle_param_repo_init(&sCr_param_val[i], &param_desc[i]);
        // User code start [P3]
        // User code end [P3]

        if (rval != 0)
            I3_LOG(LOG_MASK_ERROR, "At param index %d, failed to initialize data (error %d)", i, rval);

    } // end for

    // rval = app_handle_param_repo_post_init();
    // User code start [P4]
    // User code end [P4]
    if (rval)
    {
        I3_LOG(LOG_MASK_ERROR, "App-specific param repo pre-init failed (error %d), continuing with init", rval);
    }
}

// Populate a parameter value structure
int crcb_parameter_read(const uint32_t pid, cr_ParameterValue *data)
{
    int rval = 0;
    affirm(data != NULL);
    if (pid >= NUM_PARAMS)
        return cr_ErrorCodes_INVALID_ID;

    //rval = app_handle_param_repo_read(&sCr_param_val[pid]);
    // User code start [P5]
    // User code end [P5]

    *data = sCr_param_val[pid];
    return rval;
}

int crcb_parameter_write(const uint32_t pid, const cr_ParameterValue *data)
{   
    if (pid >= NUM_PARAMS)
        return cr_ErrorCodes_INVALID_ID;
    int rval = 0;
    I3_LOG(LOG_MASK_PARAMS, "Write param, pid %d (%d)", pid, data->parameter_id);
    I3_LOG(LOG_MASK_PARAMS, "  timestamp %d", data->timestamp);
    I3_LOG(LOG_MASK_PARAMS, "  which %d", data->which_value);

    // rval = app_handle_param_repo_write((cr_ParameterValue *) data);
    // User code start [P6]
    // User code end [P6]

    if (rval != 0)
    {
        // Invalid data or NVM storage failed
        return rval;
    }
    sCr_param_val[pid].timestamp = data->timestamp;
    sCr_param_val[pid].which_value = data->which_value;

    switch ((data->which_value - cr_ParameterValue_uint32_value_tag))
    {
        case cr_ParameterDataType_UINT32:
            sCr_param_val[pid].value.uint32_value = data->value.uint32_value;
            break;
        case cr_ParameterDataType_INT32:
            sCr_param_val[pid].value.int32_value = data->value.int32_value;
            break;
        case cr_ParameterDataType_FLOAT32:
            sCr_param_val[pid].value.float32_value = data->value.float32_value;
            break;
        case cr_ParameterDataType_UINT64:
            sCr_param_val[pid].value.uint64_value = data->value.uint64_value;
            break;
        case cr_ParameterDataType_INT64:
            sCr_param_val[pid].value.int64_value = data->value.int64_value;
            break;
        case cr_ParameterDataType_FLOAT64:
            sCr_param_val[pid].value.float64_value = data->value.float64_value;
            break;
        case cr_ParameterDataType_BOOL:
            sCr_param_val[pid].value.bool_value = data->value.bool_value;
            break;
        case cr_ParameterDataType_STRING:
            memcpy(sCr_param_val[pid].value.string_value,
                   data->value.string_value, REACH_PVAL_STRING_LEN);
            sCr_param_val[pid].value.string_value[REACH_PVAL_STRING_LEN-1] = 0;
            I3_LOG(LOG_MASK_PARAMS, "String value: %s",
                   sCr_param_val[pid].value.string_value);
            break;
        case cr_ParameterDataType_BIT_FIELD:
            sCr_param_val[pid].value.bitfield_value = data->value.bitfield_value;
            break;
        case cr_ParameterDataType_ENUMERATION:
            sCr_param_val[pid].value.enum_value = data->value.enum_value;
            break;
        case cr_ParameterDataType_BYTE_ARRAY:
            memcpy(sCr_param_val[pid].value.bytes_value.bytes,
                   data->value.bytes_value.bytes, 
                   REACH_PVAL_BYTES_LEN);
            if (data->value.bytes_value.size > REACH_PVAL_BYTES_LEN)
            {
                LOG_ERROR("Parameter write of bytes has invalid size %d > %d",
                          data->value.bytes_value.size, REACH_PVAL_BYTES_LEN);
                sCr_param_val[pid].value.bytes_value.size = REACH_PVAL_BYTES_LEN;
            }
            else
            {
                sCr_param_val[pid].value.bytes_value.size = data->value.bytes_value.size;
            }
            LOG_DUMP_MASK(LOG_MASK_PARAMS, "bytes value",
                          sCr_param_val[pid].value.bytes_value.bytes,
                          sCr_param_val[pid].value.bytes_value.size);
            break;
        default:
            LOG_ERROR("Parameter write which_value %d not recognized.", 
                          data->which_value);
            rval = 1;
            break;
    }  // end switch
    return rval;
}


int crcb_parameter_get_count()
{
    int i;
    int numAvailable = 0;
    for (i=0; i<NUM_PARAMS; i++)
    {
        if (crcb_access_granted(cr_ServiceIds_PARAMETER_REPO, param_desc[i].id))
            numAvailable++;
    }
    return numAvailable;
}

// return a number that changes if the parameter descriptions have changed.
uint32_t crcb_compute_parameter_hash(void)
{
    // Note that the layout of the structure param_desc differs by compiler.
    // The hash computed on windows won't match that computed on SiLabs.
    uint32_t *ptr = (uint32_t*)param_desc;
    size_t sz = sizeof(param_desc)/(sizeof(uint32_t));
    // LOG_DUMP_MASK(LOG_MASK_PARAMS, "Raw Params", cptr, sizeof(param_desc));

    // The hash should be different based on access permission
    uint32_t hash = 0;
    for (size_t jj = 0; jj < NUM_PARAMS; jj++)
    {
        if (crcb_access_granted(cr_ServiceIds_PARAMETER_REPO, jj))
        {
            for (size_t i= 0; i<sizeof(cr_ParameterInfo); i++)
                hash ^= ptr[i];
        }
    }

#ifdef NUM_EX_PARAMS
    ptr = (uint32_t*)param_ex_desc;
    size_t sz1 = sizeof(param_ex_desc)/(sizeof(uint32_t));

    for (size_t i= 0; i<sz1; i++)
        hash ^= ptr[i];

    I3_LOG(LOG_MASK_PARAMS, "%s: hash 0x%x over %d+%d = %d words.\n",
           __FUNCTION__, hash, sz, sz1, sz+sz1);
#else
    I3_LOG(LOG_MASK_PARAMS, "%s: hash 0x%x over %d words.\n",
           __FUNCTION__, hash, sz);
#endif // NUM_EX_PARAMS

    return hash;
}

static int sCurrentParameter = 0;

// Resets the application's pointer into the parameter table such that
// the next call to crcb_parameter_discover_next() will return the
// description of this parameter.
int crcb_parameter_discover_reset(const uint32_t pid)
{
    if (pid >= NUM_PARAMS)
    {
        sCurrentParameter = 0;
        I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset > defaults to %d", pid, sCurrentParameter);
        return cr_ErrorCodes_INVALID_ID;
    }
    sCurrentParameter = pid;
    int i;
    sCurrentParameter = 0;  // in case none match
    for (i = 0; i < NUM_PARAMS; i++)
    {
        if (param_desc[i].id == pid) {
            sCurrentParameter = i;
            // I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset to %d", pid, sCurrentParameter);
            return 0;
        }
    }
    I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset not found defaults to %d", pid, sCurrentParameter);
    return cr_ErrorCodes_INVALID_ID;
}

// Gets the parameter description for the next parameter.
// Allows the stack to iterate through the parameter list.
// The caller provides a cr_ParameterInfo containing string pointers that will be overwritten.
// The app owns the string pointers which must not be on the stack.
int crcb_parameter_discover_next(cr_ParameterInfo *ppDesc)
{
    if (sCurrentParameter >= NUM_PARAMS)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: sCurrentParameter (%d) >= NUM_PARAMS (%d)",
               __FUNCTION__, sCurrentParameter, NUM_PARAMS);
        return cr_ErrorCodes_NO_DATA;
    }
    while (!crcb_access_granted(cr_ServiceIds_PARAMETER_REPO, param_desc[sCurrentParameter].id))
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: sCurrentParameter (%d) skip, access not granted",
                   __FUNCTION__, sCurrentParameter);
        sCurrentParameter++;
        if (sCurrentParameter >= NUM_PARAMS)
        {
            I3_LOG(LOG_MASK_PARAMS, "%s: skipped to sCurrentParameter (%d) >= NUM_PARAMS (%d)",
                   __FUNCTION__, sCurrentParameter, NUM_PARAMS);
            return cr_ErrorCodes_NO_DATA;
        }
    }
    *ppDesc = param_desc[sCurrentParameter];
    sCurrentParameter++;
    return 0;
}

// In parallel to the parameter discovery, use this to find out 
// about enumerations and bitfields
static int sCurrentExParam = 0;
static int sRequestedParamPid = -1; // negative means all

int crcb_parameter_ex_get_count(const int32_t pid)
{
#ifdef NUM_EX_PARAMS
    if (pid < 0)  // all 
        return NUM_EX_PARAMS;

    int num_ex_msgs = 0;

    for (int i=0; i<NUM_EX_PARAMS; i++) {
        if ((int32_t)param_ex_desc[i].pei_id == pid) {
            num_ex_msgs++;
        }
    }
    return num_ex_msgs;
#else
    return 0;
#endif // NUM_EX_PARAMS
}

int crcb_parameter_ex_discover_reset(const int32_t pid)
{
    // unlike the full params, reset of param_ex always goes to zero.
    sCurrentExParam = 0;
    sRequestedParamPid = pid;
    return 0;
}

int crcb_parameter_ex_discover_next(cr_ParamExInfoResponse *pDesc)
{
    affirm(pDesc);
    pDesc->keys_count = 0;
#ifdef NUM_EX_PARAMS
    if (sCurrentExParam>=NUM_EX_PARAMS)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: No more ex params.", __FUNCTION__);
        return cr_ErrorCodes_INVALID_ID;
    }

    if (sRequestedParamPid < 0)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: For all, return param_ex %d.", __FUNCTION__, sCurrentExParam);
        *pDesc = param_ex_desc[sCurrentExParam];
        sCurrentExParam++;
        return 0;
    }

    for (int i=sCurrentExParam; i<NUM_EX_PARAMS; i++)
    {
        if ((int32_t)param_ex_desc[i].pei_id == sRequestedParamPid)
        {
            I3_LOG(LOG_MASK_PARAMS, "%s: For pid %d, return param_ex %d.",
                   __FUNCTION__, sRequestedParamPid, sCurrentExParam);
            *pDesc = param_ex_desc[i];
            sCurrentExParam = i+1;;
            return 0;
        }
    }
    // should not get here.
    I3_LOG(LOG_MASK_PARAMS, "%s: No more ex params 2.", __FUNCTION__);
#endif // NUM_EX_PARAMS
    return cr_ErrorCodes_INVALID_ID;
}

// User functions here
// User code start [P7]
// User code end [P7]

